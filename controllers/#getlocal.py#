import logging

from pylons import request, response, session, tmpl_context as c, url
from pylons.controllers.util import abort, redirect
from sqlalchemy.orm import join
import re
from scatterbrainz.model.track import Track
from scatterbrainz.model.artist import Artist
from scatterbrainz.model.album import Album
from scatterbrainz.model.meta import Session
import urllib
from scatterbrainz.lib.base import BaseController, render
import os
import simplejson as sjson

from scatterbrainz.external import my_MB

log = logging.getLogger(__name__)

class GetlocalController(BaseController):

    def blah(self):
        return "HELLO"

    def allartists(self):
        artists = Session.query(Artist)
        out = []
        for  a in artists:

            name = a.name
            mbid = a.mbid
            out.append({'tostring':name,
                        'artist_name':name,
                        'artist_mbid':mbid,
                        'datatype':'artist'})
            
        return sjson.dumps(out)
 
    def allalbums(self):
        if request.params.has_key('mbid') :
            mbid = request.params['mbid']
            artist = Session.query(Artist).filter_by(mbid=mbid)[0].id;
            albums = Session.query(Album).filter_by(artistid=artist);
        else:
            albums = Session.query(Album)
        
        
        out = []
        for  a in albums:

            name = a.name
            mbid = a.mbid
            out.append({'tostring':name,
                        'album_name':name,
                        'album_mbid':mbid,
                        'datatype':'album'})
            
        return sjson.dumps(out)

    def alltracks(self):
        trk_total_limit = 200;
        trk_artist_limit = 10;

        tracks = Session.query(Track)
        count = 0
        namefun = lambda x: x.id3title
        out = []
        this_artist_count = 0 
        last_artist = ''
        for t in tracks:
            name = namefun(t)

            this_artist = t.artistid
            if this_artist == last_artist:
                this_artist_count = this_artist_count + 1
            else:
                this_artist_count = 0
                last_artist = this_artist
            if this_artist_count < trk_artist_limit:
                json = {
                    'track_name':name,
                    'url':self.track_URL_from_id(t.id),
                    'track_id':t.id,
                    'albumid':t.albumid,
                    'artistid':t.artistid,
                    'datatype':'track',
                    'tostring':name
                    }
                out.append(json)
                count = count + 1
                if count > trk_total_limit: break

        return sjson.dumps(out)
    
    def trackArtistAlbumsLOCAL(self):
        trackid = request.params['trackid']

        #note that we can do this because there is 
        #only a single foreign key matched between 
        #tracks and albums.
        artistid=Session.query(Track).filter_by(id=trackid)[0].artistid
        joined=Session.query(Track).filter_by(artistid=artistid)

        aids = []
        out = []
        for t in joined:
            aid = t.albumid
            if not aid in aids:
                aids.append(aid)
                year_re = re.compile('[0-9]{4}')
                early_year = (re.search(year_re,t.id3date)).group()
                json = {
                    'aid':aid,
                    'mbid':t.album.mbid,
                    'name':t.album.name,
                    'year':early_year
                    }
                out.append(json)
        return sjson.dumps(out)
    
    def trackArtistAlbumsMB(self):
        trackid = request.params['trackid']

        track = Session.query(Track).filter_by(id=trackid).one()
        mbid = track.mbid
        results = my_MB.getAlbumsByArtist(mbid)
        out = []
        for r in results:
            json={
                'id':  r.id,
                'name':r.title 
                }
            out.append(json)

        return sjson.dumps(out)

    def trackRelationsMB(self):
        trackid=request.params['trackid']
        track = Session.query(Track).filter_by(id=trackid).one()
        mbid=track.mbid
        artist_mbid=track.artist.mbid
        release_mbid=track.album.mbid

        results = my_MB.getTrackRelations(mbid) 
        out = {}
        tresults = []
        for r in results:
            json = {
                'type':r.getType()
                }
            tresults.append(json);
        out['track_relations'] =tresults

        results =  my_MB.getArtistRelations(artist_mbid) 
        artist_relations=[]
        for r in results:
            json = {
                'type':r.getType()
                }
            artist_relations.append(json);
        out['artist_relations'] =artist_relations

        results =  my_MB.getReleaseRelations(release_mbid) 
        album_relations=[]
        for r in results:
            json = {
                'type':r.getType()
                }
            album_relations.append(json);
        out['album_relations'] =album_relations

        return sjson.dumps(out);

    def track_URL_from_id(self,id):
        track = Session.query(Track).filter_by(id=id)[0]
        path = os.path.join('.music',track.filepath)
        url = self._path_url(path)
        return url

    def _path_url(self, path):         
        return os.path.join('http://localhost:5000',urllib.pathname2url(path))
        

    

